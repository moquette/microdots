#!/usr/bin/env bash
#
# dots bootstrap - Initial system setup
# Sets up gitconfig, installs symlinks, and optionally runs installers
#

# Don't use set -e to prevent early exit on non-critical errors
# We'll handle errors explicitly where needed

# Get the dotfiles root directory
DOTFILES_ROOT="$(cd "$(dirname "$0")/../.." && pwd -P)"
CORE_DIR="$DOTFILES_ROOT/core"

# Source common functions
source "$CORE_DIR/lib/common.sh"

# Parse command line flags
run_install=false
force_relink=false
while test $# -gt 0; do
  case "$1" in
    --install)
      run_install=true
      ;;
    --force-relink)
      force_relink=true
      ;;
    *)
      ;;
  esac
  shift
done

header "ðŸ”§ Dotfiles Bootstrap"

# User input function for interactive prompts
user() {
  prompt "$1"
  echo ""  # Add newline after prompt
}

setup_gitconfig() {
  # Check for existing gitconfig in local directory first
  local local_gitconfig="$DOTFILES_ROOT/.local/git/gitconfig.local.symlink"
  local public_gitconfig="$DOTFILES_ROOT/git/gitconfig.local.symlink"
  
  if [ -f "$local_gitconfig" ]; then
    success "Git user configuration found in local"
  elif [ -f "$public_gitconfig" ]; then
    success "gitconfig already configured"
  else
    progress "Setting up gitconfig"

    git_credential='cache'
    if [[ "$(uname -s)" == "Darwin" ]]; then
      git_credential='osxkeychain'
    fi

    user " - What is your github author name?"
    read -r -e git_authorname
    user " - What is your github author email?"
    read -r -e git_authoremail

    sed -e "s/AUTHORNAME/$git_authorname/g" \
        -e "s/AUTHOREMAIL/$git_authoremail/g" \
        -e "s/GIT_CREDENTIAL_HELPER/$git_credential/g" \
        "$DOTFILES_ROOT/git/gitconfig.local.symlink.example" > \
        "$public_gitconfig"

    success "gitconfig configured"
  fi
}


link_file() {
  local src=$1 dst=$2
  local overwrite= backup= skip=
  local action=

  if [ -f "$dst" -o -d "$dst" -o -L "$dst" ]; then

    if [[ "$overwrite_all" == "false" ]] && [[ "$backup_all" == "false" ]] && [[ "$skip_all" == "false" ]]; then

      # Use readlink without -f for macOS compatibility
      local currentSrc="$(readlink "$dst" 2>/dev/null || echo "")"

      if [[ "$currentSrc" == "$src" ]]; then
        skip=true;
      else
        warning "File already exists: $dst ($(basename "$src"))"
        prompt "What do you want to do? [s]kip, [S]kip all, [o]verwrite, [O]verwrite all, [b]ackup, [B]ackup all?"
        read -r -n 1 action
        blank

        case "$action" in
          o )
            overwrite=true;;
          O )
            overwrite_all=true;;
          b )
            backup=true;;
          B )
            backup_all=true;;
          s )
            skip=true;;
          S )
            skip_all=true;;
          * )
            ;;
        esac
      fi
    fi

    overwrite=${overwrite:-$overwrite_all}
    backup=${backup:-$backup_all}
    skip=${skip:-$skip_all}

    if [[ "$overwrite" == "true" ]]; then
      rm -rf "$dst"
      success "Removed $dst"
    fi

    if [[ "$backup" == "true" ]]; then
      mv "$dst" "${dst}.backup"
      success "Moved $dst to ${dst}.backup"
    fi

    if [[ "$skip" == "true" ]]; then
      success "Skipped $src"
    fi
  fi

  if [[ "$skip" != "true" ]]; then
    # Use symlink library for consistent behavior
    source "$DOTFILES_ROOT/core/lib/symlink.sh"
    create_bootstrap_symlink "$1" "$2" "$(basename "$2")"
  fi
}

install_dotfiles() {
  subheader "Symlinks"
  progress "Installing dotfiles symlinks"

  # Source the symlink library for consistent behavior
  source "$DOTFILES_ROOT/core/lib/symlink.sh"

  # Create dots command symlink
  create_command_symlink "$DOTFILES_ROOT/core/dots" "$DOTFILES_ROOT/bin/dots" "dots" || warning "Could not create dots command symlink"

  # Use the discovered dotlocal path from auto-discovery
  local local_dir="${DISCOVERED_DOTLOCAL_PATH:-}"

  # If auto-discovery didn't run or didn't find anything, try fallback
  if [[ -z "$local_dir" ]] && [[ -f "$DOTFILES_ROOT/dotfiles.conf" ]]; then
    # Source only variable assignments, not commands
    eval "$(grep '^DOTLOCAL=' "$DOTFILES_ROOT/dotfiles.conf" 2>/dev/null || true)"

    # Expand the path to handle tilde and variables
    if [[ -n "${DOTLOCAL:-}" ]]; then
      local_dir=$(expand_path "$DOTLOCAL")
    fi
  fi

  # Report what we're using
  if [[ -n "$local_dir" ]]; then
    info "Using local configuration directory: $local_dir"
  else
    info "No local configuration directory found - using public configs only"
  fi

  # Use the proper two-phase symlink creation with precedence
  # This will handle both public and local symlinks correctly
  create_all_symlinks_with_precedence "$DOTFILES_ROOT" "$local_dir" "false" "false" || warning "Some symlinks could not be created"

  info "Symlink installation completed"
}

setup_dotlocal_symlink() {
  subheader "Dotlocal Auto-Discovery"

  # Source the path resolution library and symlink library
  source "$CORE_DIR/lib/paths.sh"
  source "$CORE_DIR/lib/symlink.sh"

  # Use the comprehensive path resolution with verbose output
  local discovered_path=$(resolve_dotlocal_path "$DOTFILES_ROOT" "true" "true")
  local discovery_method=$(get_dotlocal_discovery_method)
  local force="${force_relink:-false}"

  # If resolve_dotlocal_path returns empty (due to infrastructure setup failure),
  # try direct discovery as fallback
  if [[ -z "$discovered_path" ]]; then
    discovered_path=$(discover_dotlocal_path "$DOTFILES_ROOT" "false")
    discovery_method=$(get_dotlocal_discovery_method)
  fi

  # Report discovery results
  success "Dotlocal discovery complete"
  info "  Path: $discovered_path"
  info "  Method: $discovery_method"

  # Create the .dotlocal symlink if we have a discovered path
  if [[ -n "$discovered_path" ]]; then
    local dotlocal_symlink="$DOTFILES_ROOT/.dotlocal"

    # Always verify and ensure correct symlink, regardless of existence
    # Bootstrap doesn't have dry_run mode, so we always execute
    if false; then
      info "Would create/verify .dotlocal symlink: .dotlocal â†’ $discovered_path"
    else
      local needs_update=false
      local current_target=""

      if [[ -L "$dotlocal_symlink" ]]; then
        current_target=$(readlink "$dotlocal_symlink")
        if [[ "$current_target" != "$discovered_path" ]]; then
          needs_update=true
          info "Updating .dotlocal symlink: $current_target â†’ $discovered_path"
        elif [[ "$force" == "true" ]]; then
          needs_update=true
          info "Force updating .dotlocal symlink (--force-relink flag)"
        fi
      elif [[ ! -e "$dotlocal_symlink" ]]; then
        needs_update=true
        info "Creating .dotlocal symlink: .dotlocal â†’ $discovered_path"
      elif [[ -e "$dotlocal_symlink" ]]; then
        warning ".dotlocal exists but is not a symlink - skipping"
      fi

      if [[ "$needs_update" == "true" ]]; then
        # Force update the symlink (remove old one if it exists)
        if [[ -L "$dotlocal_symlink" ]] || [[ -e "$dotlocal_symlink" ]]; then
          rm -f "$dotlocal_symlink"
        fi

        if ! create_infrastructure_symlink "$discovered_path" "$dotlocal_symlink" ".dotlocal" "false" "true"; then
          warning "Could not create .dotlocal symlink (path may contain special characters)"
          warning "You can manually create it later with: ln -s '$discovered_path' '$dotlocal_symlink'"
        else
          success ".dotlocal symlink updated successfully"
        fi
      else
        info ".dotlocal symlink already correct: â†’ $discovered_path"
      fi
    fi

    # Also create the core symlink in dotlocal for library access (don't fail on error)
    setup_dotlocal_infrastructure "$discovered_path" "$DOTFILES_ROOT" || warning "Some infrastructure symlinks could not be created"
  fi

  # Export for use by other functions
  export DISCOVERED_DOTLOCAL_PATH="$discovered_path"
}

install_homebrew() {
  if [[ "$(uname -s)" == "Darwin" ]]; then
    subheader "Homebrew Installation"
    info "Checking for Homebrew..."

    if ! command -v brew >/dev/null 2>&1; then
      progress "Installing Homebrew (this may take a few minutes)..."

      # Run the Homebrew installer with proper output
      if "$DOTFILES_ROOT/homebrew/install.sh"; then
        # Setup Homebrew environment for the rest of this script
        if [ -x /opt/homebrew/bin/brew ]; then
          eval "$(/opt/homebrew/bin/brew shellenv)"
        elif [ -x /usr/local/bin/brew ]; then
          eval "$(/usr/local/bin/brew shellenv)"
        fi
        success "Homebrew installed"
      else
        error "Failed to install Homebrew"
        return 1
      fi
    else
      success "Homebrew already installed"
    fi
  fi
}

# Main bootstrap sequence
main() {
  # Essential setup
  setup_gitconfig
  setup_dotlocal_symlink  # MUST happen before install_dotfiles to ensure .local exists
  install_dotfiles

  # Debug: Ensure we reach this point
  info "About to install Homebrew..."
  install_homebrew

  # Run installers if requested
  if [[ "$run_install" == "true" ]]; then
    subheader "Running Installers"
    progress "Installing topic configurations"
    
    # Setup Homebrew environment first if on macOS
    if [[ "$(uname -s)" == "Darwin" ]]; then
      if [ -x /opt/homebrew/bin/brew ]; then
        eval "$(/opt/homebrew/bin/brew shellenv)"
      elif [ -x /usr/local/bin/brew ]; then
        eval "$(/usr/local/bin/brew shellenv)"
      fi
    fi
    
    # Run the install command
    if "$CORE_DIR/commands/install"; then
      success "Installers completed"
    else
      error "Error running installers"
      exit 1
    fi
  fi

  blank
  separator
  blank
  success "ðŸŽ‰ Bootstrap complete!"
  blank

  # Only show next steps if not running with --install
  if [[ "$run_install" != "true" ]]; then
    subheader "Next Steps"
    list_item "Run 'dots install' to install all topic configurations"
    list_item "Run 'source ~/.zshrc' to reload your shell"
  else
    info "Run 'source ~/.zshrc' to reload your shell and start using your new configuration!"
  fi
}

# Run main function
main
