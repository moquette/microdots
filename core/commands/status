#!/usr/bin/env bash
#
# dots status - Show dotfiles system configuration and status
#

set -e

# Get the dotfiles root directory
DOTFILES_ROOT="$(cd "$(dirname "$0")/../.." && pwd -P)"
CORE_DIR="$DOTFILES_ROOT/core"

# Source libraries
source "$CORE_DIR/lib/common.sh"
source "$CORE_DIR/lib/validate-config.sh"
source "$CORE_DIR/lib/ui.sh"

# Load DOTLOCAL or LOCAL_DOTS from dotfiles.conf if it exists
LOCAL_DOTS=""
DOTLOCAL=""
if [[ -f "$DOTFILES_ROOT/dotfiles.conf" ]]; then
    # Source only variable assignments, not commands
    eval "$(grep '^[A-Z_]*=' "$DOTFILES_ROOT/dotfiles.conf" 2>/dev/null || true)"
    
    # Support both variable names (DOTLOCAL takes precedence)
    if [[ -n "$DOTLOCAL" ]]; then
        LOCAL_DOTS="$DOTLOCAL"  # Use new name internally
    elif [[ -n "$LOCAL_DOTS" ]]; then
        DOTLOCAL="$LOCAL_DOTS"  # Backward compatibility
    fi
fi

# Parse options
show_symlinks=false
verbose=false

while test $# -gt 0; do
  case "$1" in
    --symlinks|-s)
      show_symlinks=true
      ;;
    --verbose|-v)
      verbose=true
      ;;
    --help)
      cat <<EOF
dots status - Show dotfiles system configuration and status

Usage: dots status [options]

Options:
  -s, --symlinks    Show all managed symlinks
  -v, --verbose     Show detailed information
  --help           Show this help message

Shows the current dotfiles configuration including:
  - Dotfiles root directory
  - Local configuration directory (if configured)
  - Configuration method (config file, symlink, directory)
  - Current symlink status

EOF
      exit 0
      ;;
    *)
      error "Unknown option: $1"
      info "Run 'dots status --help' for usage"
      exit 1
      ;;
  esac
  shift
done

header "ðŸ“Š Dotfiles System Status"

# Basic configuration
subheader "Core Configuration"
key_value "DOTFILES_ROOT" "$DOTFILES_ROOT"

# Check for dotfiles.conf
if [[ -f "$DOTFILES_ROOT/dotfiles.conf" ]]; then
    key_value "Config file" "Present"
    if [[ "$verbose" == "true" ]]; then
        if [[ -n "${LOCAL_PATH:-}" ]]; then
            indent "LOCAL_PATH: $LOCAL_PATH" 2
        fi
        if [[ -n "${BACKUP_PATH:-}" ]]; then
            indent "BACKUP_PATH: $BACKUP_PATH" 2
        fi
    fi
else
    key_value "Config file" "Not found"
fi

blank
subheader "Local Configuration"

# Local directory status
if [[ -n "$DOTLOCAL" ]]; then
    # Expand tilde in DOTLOCAL path
    DOTLOCAL_EXPANDED=$(expand_path "$DOTLOCAL")
    key_value "DOTLOCAL" "$DOTLOCAL"
    
    if [[ -d "$DOTLOCAL_EXPANDED" ]]; then
        key_value "Status" "Active"
        if [[ "$verbose" == "true" ]]; then
            # Count symlink files in local
            local_symlink_count=$(find "$DOTLOCAL_EXPANDED" -name "*.symlink" 2>/dev/null | wc -l | tr -d ' ')
            key_value "Symlink files" "$local_symlink_count"
            
            # Check for important local files
            info "Key files:"
            [[ -f "$DOTLOCAL_EXPANDED/localrc.symlink" ]] && list_item "localrc.symlink"
            [[ -d "$DOTLOCAL_EXPANDED/shell" ]] && list_item "shell/"
            [[ -d "$DOTLOCAL_EXPANDED/bin" ]] && list_item "bin/"
            [[ -d "$DOTLOCAL_EXPANDED/ssh.symlink" ]] && list_item "ssh.symlink/"
            
            # Check core symlink
            if [[ -L "$DOTLOCAL_EXPANDED/core" ]]; then
                core_target=$(readlink "$DOTLOCAL_EXPANDED/core")
                if [[ "$core_target" == "$DOTFILES_ROOT/core" ]]; then
                    list_item "core â†’ $DOTFILES_ROOT/core âœ“"
                else
                    list_item "core â†’ $core_target (incorrect)"
                fi
            elif [[ -e "$DOTLOCAL_EXPANDED/core" ]]; then
                list_item "core (not a symlink!)"
            fi
        fi
    else
        key_value "Status" "Directory not found"
        warning "Local directory configured but does not exist: $DOTLOCAL"
    fi
else
    key_value "DOTLOCAL" "Not configured"
    key_value "Status" "Using public configs only"
fi

# Check for symlinks at ~/.dotfiles/.dotlocal and ~/.dotfiles/.local
blank
subheader "Symlink Status"

# Check .dotlocal (primary)
if [[ -L "$DOTFILES_ROOT/.dotlocal" ]]; then
    target=$(readlink "$DOTFILES_ROOT/.dotlocal")
    info "~/.dotfiles/.dotlocal â†’ $target"
    if [[ ! -d "$target" ]]; then
        warning "  Symlink target does not exist!"
    fi
elif [[ -d "$DOTFILES_ROOT/.dotlocal" ]]; then
    warning "~/.dotfiles/.dotlocal: Regular directory (not a symlink)"
else
    info "~/.dotfiles/.dotlocal: Not present"
fi

# Check .local (legacy/backward compatibility)
if [[ -L "$DOTFILES_ROOT/.local" ]]; then
    target=$(readlink "$DOTFILES_ROOT/.local")
    info "~/.dotfiles/.local â†’ $target (legacy)"
    if [[ ! -d "$target" ]]; then
        warning "  Symlink target does not exist!"
    fi
elif [[ -d "$DOTFILES_ROOT/.local" ]]; then
    warning "~/.dotfiles/.local: Regular directory (not a symlink)"
else
    info "~/.dotfiles/.local: Not present"
fi

# Check ~/.dotlocal directory
if [[ -d "$HOME/.dotlocal" ]]; then
    info "~/.dotlocal: Directory exists"
    if [[ "$DOTLOCAL" == "$HOME/.dotlocal" ]]; then
        indent "Status: Currently in use" 2
    else
        indent "Status: Present but not in use" 2
    fi
fi

# Show managed symlinks if requested
if [[ "$show_symlinks" == "true" ]]; then
    blank
    source "$CORE_DIR/lib/symlink.sh"
    
    # Show standard dotfile symlinks
    subheader "Standard Dotfile Symlinks"
    
    # Count symlinks first
    public_symlink_count=0
    local_symlink_count=0
    broken_symlink_count=0
    
    # First pass to count
    while IFS= read -r symlink; do
        if [[ -L "$symlink" ]]; then
            target=$(readlink "$symlink")
            if [[ ! -e "$symlink" ]]; then
                broken_symlink_count=$((broken_symlink_count + 1))
            elif [[ "$target" == *"$DOTFILES_ROOT"* ]]; then
                public_symlink_count=$((public_symlink_count + 1))
            elif [[ -n "$DOTLOCAL_EXPANDED" && "$target" == *"$DOTLOCAL_EXPANDED"* ]]; then
                local_symlink_count=$((local_symlink_count + 1))
            fi
        fi
    done < <(find "$HOME" -maxdepth 1 -name ".*" 2>/dev/null)
    
    total_standard=$((public_symlink_count + local_symlink_count + broken_symlink_count))
    echo "${BOLD}Home directory: $total_standard symlinks (Public: $public_symlink_count, Local: $local_symlink_count)${RESET}"
    
    # Second pass to display
    while IFS= read -r symlink; do
        if [[ -L "$symlink" ]]; then
            target=$(readlink "$symlink")
            status=""
            
            # Check if symlink is broken
            if [[ ! -e "$symlink" ]]; then
                status=" âœ— BROKEN"
            fi
            
            # Always show all symlinks when --symlinks is used
            indent "$(basename "$symlink") â†’ $target$status"
        fi
    done < <(find "$HOME" -maxdepth 1 -name ".*" 2>/dev/null | sort)
    
    # Claude-specific symlinks
    blank
    subheader "Claude Configuration Symlinks"
    
    claude_symlink_count=0
    claude_broken_count=0
    
    # Check Claude commands
    if [[ -d "$HOME/.claude/commands" ]]; then
        command_count=$(find "$HOME/.claude/commands" -type l 2>/dev/null | wc -l | tr -d ' ')
        echo "${BOLD}Commands: $command_count symlinks${RESET}"
        while IFS= read -r symlink; do
            if [[ -L "$symlink" ]]; then
                target=$(readlink "$symlink")
                status=""
                if [[ ! -e "$symlink" ]]; then
                    status=" âœ— BROKEN"
                    claude_broken_count=$((claude_broken_count + 1))
                else
                    claude_symlink_count=$((claude_symlink_count + 1))
                fi
                
                # Always show in the clean format
                indent "$(basename "$symlink") â†’ $target$status"
            fi
        done < <(find "$HOME/.claude/commands" -type l 2>/dev/null | sort)
    fi
    
    # Check Claude agents
    if [[ -d "$HOME/.claude/agents" ]]; then
        agent_count=$(find "$HOME/.claude/agents" -type l 2>/dev/null | wc -l | tr -d ' ')
        echo "${BOLD}Agents: $agent_count symlinks${RESET}"
        while IFS= read -r symlink; do
            if [[ -L "$symlink" ]]; then
                target=$(readlink "$symlink")
                status=""
                if [[ ! -e "$symlink" ]]; then
                    status=" âœ— BROKEN"
                    claude_broken_count=$((claude_broken_count + 1))
                else
                    claude_symlink_count=$((claude_symlink_count + 1))
                fi
                
                # Always show all agent symlinks when --symlinks is used
                indent "$(basename "$symlink") â†’ $target$status"
            fi
        done < <(find "$HOME/.claude/agents" -type l 2>/dev/null | sort)
    fi
    
    # Check Claude global files
    echo "${BOLD}Global files: 2 symlinks${RESET}"
    for file in PROTOCOL.md CLAUDE.md; do
        if [[ -L "$HOME/.claude/$file" ]]; then
            target=$(readlink "$HOME/.claude/$file")
            status=""
            if [[ ! -e "$HOME/.claude/$file" ]]; then
                status=" âœ— BROKEN"
                claude_broken_count=$((claude_broken_count + 1))
            else
                claude_symlink_count=$((claude_symlink_count + 1))
            fi
            
            indent "$file â†’ $target$status"
        fi
    done
    
    # Check Claude Desktop MCP config
    CLAUDE_DESKTOP_CONFIG="$HOME/Library/Application Support/Claude/claude_desktop_config.json"
    if [[ -L "$CLAUDE_DESKTOP_CONFIG" ]]; then
        echo "${BOLD}MCP Configuration: 1 symlink${RESET}"
        target=$(readlink "$CLAUDE_DESKTOP_CONFIG")
        status=""
        if [[ ! -e "$CLAUDE_DESKTOP_CONFIG" ]]; then
            status=" âœ— BROKEN"
            claude_broken_count=$((claude_broken_count + 1))
        else
            claude_symlink_count=$((claude_symlink_count + 1))
        fi
        
        indent "claude_desktop_config.json â†’ $target$status"
    fi
    
    # Summary
    blank
    subheader "Symlink Summary"
    echo "${BOLD}Standard dotfiles â†’ $((public_symlink_count + local_symlink_count)) total${RESET}"
    indent "Public configs â†’ $public_symlink_count"
    indent "Local overrides â†’ $local_symlink_count"
    [[ $broken_symlink_count -gt 0 ]] && indent "Broken â†’ $broken_symlink_count âœ—"
    
    echo "${BOLD}Claude configuration â†’ $claude_symlink_count total${RESET}"
    indent "Commands â†’ $(find "$HOME/.claude/commands" -type l 2>/dev/null | wc -l | tr -d ' ')"
    indent "Agents â†’ $(find "$HOME/.claude/agents" -type l 2>/dev/null | wc -l | tr -d ' ')"
    indent "Global files â†’ 2"
    indent "MCP config â†’ 1"
    [[ $claude_broken_count -gt 0 ]] && indent "Broken â†’ $claude_broken_count âœ—"
    
    total_symlinks=$((public_symlink_count + local_symlink_count + claude_symlink_count))
    total_broken=$((broken_symlink_count + claude_broken_count))
    
    blank
    if [[ $total_broken -gt 0 ]]; then
        error "â€º Total â†’ $total_symlinks symlinks ($total_broken BROKEN)"
        warning "Run 'dots relink --force' to fix broken symlinks"
    else
        success "â€º Total â†’ $total_symlinks symlinks (all valid)"
    fi
fi

# Summary
blank
subheader "Summary"
if [[ -n "$DOTLOCAL" ]] && [[ -d "$DOTLOCAL_EXPANDED" ]]; then
    success "Local overrides are ACTIVE from: $DOTLOCAL"
    info "Run 'dots relink' to refresh symlinks with local precedence"
else
    info "Using public configurations only"
    info "To enable local overrides:"
    info "  1. Create a local directory: mkdir ~/.dotlocal"
    info "  2. Add your private configs with .symlink extension"
    info "  3. Run 'dots relink' to apply changes"
fi

blank

# Configuration Validation
subheader "Configuration Validation"
if validate_configuration >/dev/null 2>&1; then
    success "No issues detected"
else
    blank
    validate_configuration 2>&1 | sed 's/^/  /'
fi

blank