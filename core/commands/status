#!/usr/bin/env bash
#
# dots status - Show dotfiles system configuration and status
#

set -e

# Get the dotfiles root directory
DOTFILES_ROOT="$(cd "$(dirname "$0")/../.." && pwd -P)"
CORE_DIR="$DOTFILES_ROOT/core"

# Source libraries
source "$CORE_DIR/lib/common.sh"
source "$CORE_DIR/lib/validate-config.sh"
source "$CORE_DIR/lib/ui.sh"
source "$CORE_DIR/lib/paths.sh"

# Load DOTLOCAL from dotfiles.conf if it exists (for backward compatibility)
DOTLOCAL=""
if [[ -f "$DOTFILES_ROOT/dotfiles.conf" ]]; then
    # Source only variable assignments, not commands
    eval "$(grep '^[A-Z_]*=' "$DOTFILES_ROOT/dotfiles.conf" 2>/dev/null || true)"
fi

# Parse options
show_symlinks=false
verbose=false

while test $# -gt 0; do
  case "$1" in
    --symlinks|-s)
      show_symlinks=true
      ;;
    --verbose|-v)
      verbose=true
      ;;
    --help)
      cat <<EOF
dots status - Show dotfiles system configuration and status

Usage: dots status [options]

Options:
  -s, --symlinks    Show all managed symlinks
  -v, --verbose     Show detailed information
  --help           Show this help message

Shows the current dotfiles configuration including:
  - Dotfiles root directory
  - Local configuration directory (if configured)
  - Configuration method (config file, symlink, directory)
  - Current symlink status

EOF
      exit 0
      ;;
    *)
      error "Unknown option: $1"
      info "Run 'dots status --help' for usage"
      exit 1
      ;;
  esac
  shift
done

header "📊 Dotfiles System Status"

# Basic configuration
subheader "Core Configuration"
key_value "DOTFILES_ROOT" "$DOTFILES_ROOT"

# Check for dotfiles.conf
if [[ -f "$DOTFILES_ROOT/dotfiles.conf" ]]; then
    key_value "Config file" "Present"
    if [[ "$verbose" == "true" ]]; then
        if [[ -n "${LOCAL_PATH:-}" ]]; then
            indent "LOCAL_PATH: $LOCAL_PATH" 2
        fi
        if [[ -n "${BACKUP_PATH:-}" ]]; then
            indent "BACKUP_PATH: $BACKUP_PATH" 2
        fi
    fi
else
    key_value "Config file" "Not found"
fi

blank
subheader "Local Configuration"

# Use the new discovery system for comprehensive status
discovered_path=$(discover_dotlocal_path "$DOTFILES_ROOT" false)
discovery_method=$(get_dotlocal_discovery_method)
dotlocal_type=$(get_dotlocal_type "$DOTFILES_ROOT")

if [[ -n "$discovered_path" ]]; then
    key_value "Path" "$discovered_path"
    key_value "Discovery Method" "$discovery_method"
    key_value "Type" "$dotlocal_type"

    if [[ -d "$discovered_path" ]]; then
        key_value "Status" "Active"

        # Count topics in local directory
        topic_count=0
        if [[ -d "$discovered_path" ]]; then
            topic_count=$(find "$discovered_path" -mindepth 1 -maxdepth 1 -type d | wc -l | tr -d ' ')
        fi
        key_value "Topics" "$topic_count"

        # Show categorized topics if marker files exist
        marker_count=$(find "$discovered_path" -name ".microdot.type" 2>/dev/null | wc -l | tr -d ' ')
        if [[ $marker_count -gt 0 ]]; then
            # Count by type
            microdot_count=$(grep -l "^type: microdot" "$discovered_path"/*/.microdot.type 2>/dev/null | wc -l | tr -d ' ')
            config_count=$(grep -l "^type: config" "$discovered_path"/*/.microdot.type 2>/dev/null | wc -l | tr -d ' ')
            private_count=$(grep -l "^type: private" "$discovered_path"/*/.microdot.type 2>/dev/null | wc -l | tr -d ' ')

            if [[ $microdot_count -gt 0 || $config_count -gt 0 || $private_count -gt 0 ]]; then
                blank
                info "Organization:"
                [[ $microdot_count -gt 0 ]] && list_item "Microdots: $microdot_count (self-contained microservices)"
                [[ $config_count -gt 0 ]] && list_item "Configs: $config_count (simple configurations)"
                [[ $private_count -gt 0 ]] && list_item "Private: $private_count (sensitive data)"

                if [[ "$verbose" == "true" ]]; then
                    blank
                    # List microdots
                    if [[ $microdot_count -gt 0 ]]; then
                        info "Microdots:"
                        for marker in "$discovered_path"/*/.microdot.type; do
                            if grep -q "^type: microdot" "$marker" 2>/dev/null; then
                                dir_name=$(basename "$(dirname "$marker")")
                                list_item "$dir_name"
                            fi
                        done | sort
                    fi

                    # List configs
                    if [[ $config_count -gt 0 ]]; then
                        info "Configs:"
                        for marker in "$discovered_path"/*/.microdot.type; do
                            if grep -q "^type: config" "$marker" 2>/dev/null; then
                                dir_name=$(basename "$(dirname "$marker")")
                                list_item "$dir_name"
                            fi
                        done | sort
                    fi

                    # List private
                    if [[ $private_count -gt 0 ]]; then
                        info "Private:"
                        for marker in "$discovered_path"/*/.microdot.type; do
                            if grep -q "^type: private" "$marker" 2>/dev/null; then
                                dir_name=$(basename "$(dirname "$marker")")
                                list_item "$dir_name (⚠️ contains sensitive data)"
                            fi
                        done | sort
                    fi
                fi
            fi
        fi

        if [[ "$verbose" == "true" ]]; then
            # Show discovery precedence path
            info "Discovery precedence resolution:"

            # Level 1: dotfiles.conf
            if [[ -f "$DOTFILES_ROOT/dotfiles.conf" ]] && [[ -n "${DOTLOCAL:-}" ]]; then
                list_item "✓ Level 1 (dotfiles.conf): $DOTLOCAL"
            else
                list_item "○ Level 1 (dotfiles.conf): Not found or empty"
            fi

            # Level 2: existing symlink
            if [[ -L "$DOTFILES_ROOT/.dotlocal" ]]; then
                symlink_target=$(readlink "$DOTFILES_ROOT/.dotlocal")
                list_item "✓ Level 2 (.dotlocal symlink): $symlink_target"
            else
                list_item "○ Level 2 (.dotlocal symlink): Not found"
            fi

            # Level 3: existing directory
            if [[ -d "$DOTFILES_ROOT/.dotlocal" ]] && [[ ! -L "$DOTFILES_ROOT/.dotlocal" ]]; then
                list_item "✓ Level 3 (.dotlocal directory): $DOTFILES_ROOT/.dotlocal"
            else
                list_item "○ Level 3 (.dotlocal directory): Not found"
            fi

            # Level 4: standard location
            if [[ -d "$HOME/.dotlocal" ]]; then
                list_item "✓ Level 4 (~/.dotlocal): $HOME/.dotlocal"
            else
                list_item "○ Level 4 (~/.dotlocal): Not found"
            fi

            # Level 5: cloud storage
            cloud_found=false
            cloud_locations=(
                "$HOME/Library/Mobile Documents/com~apple~CloudDocs/Dotlocal"
                "$HOME/Library/Mobile Documents/com~apple~CloudDocs/Dotfiles/dotlocal"
                "$HOME/Dropbox/Dotlocal"
                "$HOME/Google Drive/Dotlocal"
                "$HOME/OneDrive/Dotlocal"
                "/Volumes/My Shared Files/Dotlocal"
            )

            for location in "${cloud_locations[@]}"; do
                if [[ -d "$location" ]]; then
                    list_item "✓ Level 5 (cloud storage): $location"
                    cloud_found=true
                    break
                fi
            done

            if [[ "$cloud_found" == "false" ]]; then
                list_item "○ Level 5 (cloud storage): Not found"
            fi

            blank
            info "Using: $discovered_path ($discovery_method)"

            # Count symlink files in local
            local_symlink_count=$(find "$discovered_path" -name "*.symlink" 2>/dev/null | wc -l | tr -d ' ')
            key_value "Symlink files" "$local_symlink_count"

            # Check for important local files
            info "Key files:"
            [[ -f "$discovered_path/localrc.symlink" ]] && list_item "localrc.symlink"
            [[ -d "$discovered_path/shell" ]] && list_item "shell/"
            [[ -d "$discovered_path/bin" ]] && list_item "bin/"
            [[ -d "$discovered_path/ssh.symlink" ]] && list_item "ssh.symlink/"

            # Check core symlink
            if [[ -L "$discovered_path/core" ]]; then
                core_target=$(readlink "$discovered_path/core")
                if [[ "$core_target" == "$DOTFILES_ROOT/core" ]]; then
                    list_item "core → $DOTFILES_ROOT/core ✓"
                else
                    list_item "core → $core_target (incorrect)"
                fi
            elif [[ -e "$discovered_path/core" ]]; then
                list_item "core (not a symlink!)"
            else
                list_item "core symlink missing (dotlocal scripts won't work)"
            fi
        fi
    else
        key_value "Status" "Directory not found"
        warning "Discovered path does not exist: $discovered_path"
    fi
else
    key_value "Path" "Not configured"
    key_value "Status" "Using public configs only"

    if [[ "$verbose" == "true" ]]; then
        info "No dotlocal directory found via 5-level auto-discovery"
        info "Run 'dots bootstrap' to create default location"
    fi
fi

# Check for symlinks at ~/.dotfiles/.dotlocal and ~/.dotfiles/.local
blank
subheader "Symlink Status"

# Check .dotlocal (primary)
if [[ -L "$DOTFILES_ROOT/.dotlocal" ]]; then
    target=$(readlink "$DOTFILES_ROOT/.dotlocal")
    info "~/.dotfiles/.dotlocal → $target"
    if [[ ! -d "$target" ]]; then
        warning "  Symlink target does not exist!"
    fi
elif [[ -d "$DOTFILES_ROOT/.dotlocal" ]]; then
    warning "~/.dotfiles/.dotlocal: Regular directory (not a symlink)"
else
    info "~/.dotfiles/.dotlocal: Not present"
fi


# Check ~/.dotlocal directory
if [[ -d "$HOME/.dotlocal" ]]; then
    info "~/.dotlocal: Directory exists"
    if [[ "$DOTLOCAL" == "$HOME/.dotlocal" ]]; then
        indent "Status: Currently in use" 2
    else
        indent "Status: Present but not in use" 2
    fi
fi

# Show managed symlinks if requested
if [[ "$show_symlinks" == "true" ]]; then
    blank
    source "$CORE_DIR/lib/symlink.sh"
    
    # Show standard dotfile symlinks
    subheader "Standard Dotfile Symlinks"
    
    # Count symlinks first
    public_symlink_count=0
    local_symlink_count=0
    broken_symlink_count=0
    
    # First pass to count
    while IFS= read -r symlink; do
        if [[ -L "$symlink" ]]; then
            target=$(readlink "$symlink")
            if [[ ! -e "$symlink" ]]; then
                broken_symlink_count=$((broken_symlink_count + 1))
            elif [[ "$target" == *"$DOTFILES_ROOT"* ]]; then
                public_symlink_count=$((public_symlink_count + 1))
            elif [[ -n "$discovered_path" && "$target" == *"$discovered_path"* ]]; then
                local_symlink_count=$((local_symlink_count + 1))
            fi
        fi
    done < <(find "$HOME" -maxdepth 1 -name ".*" 2>/dev/null)
    
    total_standard=$((public_symlink_count + local_symlink_count + broken_symlink_count))
    echo "${BOLD}Home directory: $total_standard symlinks (Public: $public_symlink_count, Local: $local_symlink_count)${RESET}"
    
    # Second pass to display
    while IFS= read -r symlink; do
        if [[ -L "$symlink" ]]; then
            target=$(readlink "$symlink")
            status=""
            
            # Check if symlink is broken
            if [[ ! -e "$symlink" ]]; then
                status=" ✗ BROKEN"
            fi
            
            # Always show all symlinks when --symlinks is used
            indent "$(basename "$symlink") → $target$status"
        fi
    done < <(find "$HOME" -maxdepth 1 -name ".*" 2>/dev/null | sort)
    
    # Claude-specific symlinks
    blank
    subheader "Claude Configuration Symlinks"
    
    claude_symlink_count=0
    claude_broken_count=0
    
    # Check Claude commands
    if [[ -d "$HOME/.claude/commands" ]]; then
        command_count=$(find "$HOME/.claude/commands" -type l 2>/dev/null | wc -l | tr -d ' ')
        echo "${BOLD}Commands: $command_count symlinks${RESET}"
        while IFS= read -r symlink; do
            if [[ -L "$symlink" ]]; then
                target=$(readlink "$symlink")
                status=""
                if [[ ! -e "$symlink" ]]; then
                    status=" ✗ BROKEN"
                    claude_broken_count=$((claude_broken_count + 1))
                else
                    claude_symlink_count=$((claude_symlink_count + 1))
                fi
                
                # Always show in the clean format
                indent "$(basename "$symlink") → $target$status"
            fi
        done < <(find "$HOME/.claude/commands" -type l 2>/dev/null | sort)
    fi
    
    # Check Claude agents
    if [[ -d "$HOME/.claude/agents" ]]; then
        agent_count=$(find "$HOME/.claude/agents" -type l 2>/dev/null | wc -l | tr -d ' ')
        echo "${BOLD}Agents: $agent_count symlinks${RESET}"
        while IFS= read -r symlink; do
            if [[ -L "$symlink" ]]; then
                target=$(readlink "$symlink")
                status=""
                if [[ ! -e "$symlink" ]]; then
                    status=" ✗ BROKEN"
                    claude_broken_count=$((claude_broken_count + 1))
                else
                    claude_symlink_count=$((claude_symlink_count + 1))
                fi
                
                # Always show all agent symlinks when --symlinks is used
                indent "$(basename "$symlink") → $target$status"
            fi
        done < <(find "$HOME/.claude/agents" -type l 2>/dev/null | sort)
    fi
    
    # Check Claude global files
    echo "${BOLD}Global files: 2 symlinks${RESET}"
    for file in PROTOCOL.md CLAUDE.md; do
        if [[ -L "$HOME/.claude/$file" ]]; then
            target=$(readlink "$HOME/.claude/$file")
            status=""
            if [[ ! -e "$HOME/.claude/$file" ]]; then
                status=" ✗ BROKEN"
                claude_broken_count=$((claude_broken_count + 1))
            else
                claude_symlink_count=$((claude_symlink_count + 1))
            fi
            
            indent "$file → $target$status"
        fi
    done
    
    # Check Claude Desktop MCP config
    CLAUDE_DESKTOP_CONFIG="$HOME/Library/Application Support/Claude/claude_desktop_config.json"
    if [[ -L "$CLAUDE_DESKTOP_CONFIG" ]]; then
        echo "${BOLD}MCP Configuration: 1 symlink${RESET}"
        target=$(readlink "$CLAUDE_DESKTOP_CONFIG")
        status=""
        if [[ ! -e "$CLAUDE_DESKTOP_CONFIG" ]]; then
            status=" ✗ BROKEN"
            claude_broken_count=$((claude_broken_count + 1))
        else
            claude_symlink_count=$((claude_symlink_count + 1))
        fi
        
        indent "claude_desktop_config.json → $target$status"
    fi
    
    # Summary
    blank
    subheader "Symlink Summary"
    echo "${BOLD}Standard dotfiles → $((public_symlink_count + local_symlink_count)) total${RESET}"
    indent "Public configs → $public_symlink_count"
    indent "Local overrides → $local_symlink_count"
    [[ $broken_symlink_count -gt 0 ]] && indent "Broken → $broken_symlink_count ✗"
    
    echo "${BOLD}Claude configuration → $claude_symlink_count total${RESET}"
    indent "Commands → $(find "$HOME/.claude/commands" -type l 2>/dev/null | wc -l | tr -d ' ')"
    indent "Agents → $(find "$HOME/.claude/agents" -type l 2>/dev/null | wc -l | tr -d ' ')"
    indent "Global files → 2"
    indent "MCP config → 1"
    [[ $claude_broken_count -gt 0 ]] && indent "Broken → $claude_broken_count ✗"
    
    total_symlinks=$((public_symlink_count + local_symlink_count + claude_symlink_count))
    total_broken=$((broken_symlink_count + claude_broken_count))
    
    blank
    if [[ $total_broken -gt 0 ]]; then
        error "› Total → $total_symlinks symlinks ($total_broken BROKEN)"
        warning "Run 'dots relink --force' to fix broken symlinks"
    else
        success "› Total → $total_symlinks symlinks (all valid)"
    fi
fi

# Summary
blank
subheader "Summary"
if [[ -n "$discovered_path" ]] && [[ -d "$discovered_path" ]]; then
    success "Local overrides are ACTIVE from: $discovered_path"
    info "Run 'dots relink' to refresh symlinks with local precedence"
else
    info "Using public configurations only"
    info "To enable local overrides:"
    info "  1. Create a local directory: mkdir ~/.dotlocal"
    info "  2. Add your private configs with .symlink extension"
    info "  3. Run 'dots relink' to apply changes"
fi

blank

# Configuration Validation
subheader "Configuration Validation"
if validate_configuration >/dev/null 2>&1; then
    success "No issues detected"
else
    blank
    validate_configuration 2>&1 | sed 's/^/  /'
fi

blank