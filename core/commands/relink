#!/usr/bin/env bash
#
# dots relink - Recreate all symlinks with local precedence
# REFACTORED: Uses symlink.sh library (eliminates code duplication)
#

set -e

# Get the dotfiles root directory
DOTFILES_ROOT="$(cd "$(dirname "$0")/../.." && pwd -P)"
CORE_DIR="$DOTFILES_ROOT/core"

# Source libraries
source "$CORE_DIR/lib/ui.sh"
source "$CORE_DIR/lib/validate-config.sh"
source "$CORE_DIR/lib/symlink.sh"
source "$CORE_DIR/lib/paths.sh"

# Load DOTLOCAL from dotfiles.conf if it exists (for backward compatibility)
DOTLOCAL=""
if [[ -f "$DOTFILES_ROOT/dotfiles.conf" ]]; then
    # Source only variable assignments, not commands
    eval "$(grep '^[A-Z_]*=' "$DOTFILES_ROOT/dotfiles.conf" 2>/dev/null || true)"
fi

# Parse options
dry_run=false
force=false
clean=false
verbose=false

while test $# -gt 0; do
  case "$1" in
    --dry-run)
      dry_run=true
      ;;
    --force)
      force=true
      ;;
    --clean)
      clean=true
      ;;
    --verbose)
      verbose=true
      SYMLINK_VERBOSE=true  # Set for symlink.sh library
      ;;
    --help)
      header "ðŸ“Ž Dots Relink"
      blank
      info "Recreate all dotfile symlinks with local precedence"
      blank
      subheader "Usage"
      info "  dots relink [options]"
      blank
      subheader "Options"
      list_item "--dry-run    Show what would be done without making changes"
      list_item "--force      Force overwrite existing files/symlinks"
      list_item "--clean      Clean broken symlinks before relinking"
      list_item "--verbose    Show detailed output"
      list_item "--help       Show this help message"
      blank
      subheader "Precedence Order"
      info "  1. Local configs (from \$DOTLOCAL if set)"
      info "  2. Public configs (from \$DOTFILES_ROOT)"
      blank
      exit 0
      ;;
    *)
      error "Unknown option: $1"
      info "Run 'dots relink --help' for usage"
      exit 1
      ;;
  esac
  shift
done

# Override the default UI callback from symlink.sh with our enhanced version
symlink_ui_callback() {
    local action="$1"
    local message="${2:-}"
    local details="${3:-}"

    case "$action" in
        "subheader") subheader "$message" ;;
        "progress") progress "$message" ;;
        "success") success "$message" ;;
        "info") info "$message" ;;
        "error") error "$message" ;;
        "skip")
            if [[ "$verbose" == "true" ]]; then
                list_item "$message"  # Use list_item for individual symlinks
            fi
            ;;
        "count") ;; # We'll handle counting in the summary
    esac
}

# Main execution
header "ðŸ“Ž Dotfiles Relink"

# Validate configuration
subheader "Configuration Validation"
progress "Validating configuration"

if [[ -f "$DOTFILES_ROOT/dotfiles.conf" ]]; then
    # Check for dangerous patterns before sourcing
    if grep -q "^[^#]*ln -s" "$DOTFILES_ROOT/dotfiles.conf" 2>/dev/null; then
        error "Uncommented 'ln -s' command found in dotfiles.conf"
        error "This would execute when the config is sourced"
        grep -n "^[^#]*ln -s" "$DOTFILES_ROOT/dotfiles.conf" | while read -r line; do
            indent "Line $line" 2
        done
        error "Comment out or remove these lines before proceeding"
        exit 1
    fi
fi

if ! validate_configuration; then
    error "Configuration errors detected"
    info "Run 'dots status' for details about the configuration issues"
    info "Fix the issues in dotfiles.conf and try again"
    exit 1
fi

success "Configuration valid"

# Show current configuration
subheader "Environment"
key_value "DOTFILES_ROOT" "$DOTFILES_ROOT"
if [[ -n "$DOTLOCAL" ]]; then
    key_value "DOTLOCAL" "$DOTLOCAL"
else
    key_value "DOTLOCAL" "Not configured"
fi

# Auto-discover and set up dotlocal infrastructure
subheader "Dotlocal Setup"
progress "Auto-discovering local configuration directory"

# Use the comprehensive path resolution
discovered_path=$(discover_dotlocal_path "$DOTFILES_ROOT" "false" "$verbose")
discovery_method=$(get_dotlocal_discovery_method)

if [[ -n "$discovered_path" ]]; then
    success "Using dotlocal path: $discovered_path"
    info "Discovery method: $discovery_method"

    # Verify .dotlocal symlink points to correct location (same logic as bootstrap)
    dotlocal_symlink="$DOTFILES_ROOT/.dotlocal"
    needs_update=false
    current_target=""

    if [[ -L "$dotlocal_symlink" ]]; then
        current_target=$(readlink "$dotlocal_symlink")
        if [[ "$current_target" != "$discovered_path" ]]; then
            needs_update=true
            if [[ "$dry_run" == "true" ]]; then
                info "[dry-run] Would update .dotlocal symlink: $current_target â†’ $discovered_path"
            else
                info "Updating .dotlocal symlink: $current_target â†’ $discovered_path"
            fi
        elif [[ "$force" == "true" ]]; then
            needs_update=true
            if [[ "$dry_run" == "true" ]]; then
                info "[dry-run] Would force update .dotlocal symlink (--force flag)"
            else
                info "Force updating .dotlocal symlink (--force flag)"
            fi
        fi
    elif [[ ! -e "$dotlocal_symlink" ]]; then
        needs_update=true
        if [[ "$dry_run" == "true" ]]; then
            info "[dry-run] Would create .dotlocal symlink: .dotlocal â†’ $discovered_path"
        else
            info "Creating .dotlocal symlink: .dotlocal â†’ $discovered_path"
        fi
    elif [[ -e "$dotlocal_symlink" ]]; then
        warning ".dotlocal exists but is not a symlink - skipping"
    fi

    if [[ "$needs_update" == "true" ]]; then
        if [[ "$dry_run" == "true" ]]; then
            info "[dry-run] Would update .dotlocal symlink to point to: $discovered_path"
        else
            # Force update the symlink (remove old one if it exists)
            if [[ -L "$dotlocal_symlink" ]] || [[ -e "$dotlocal_symlink" ]]; then
                rm -f "$dotlocal_symlink"
            fi

            if ! create_infrastructure_symlink "$discovered_path" "$dotlocal_symlink" ".dotlocal" "false" "false"; then
                warning "Could not create .dotlocal symlink (path may contain special characters)"
                warning "You can manually create it later with: ln -s '$discovered_path' '$dotlocal_symlink'"
            else
                success ".dotlocal symlink updated successfully"
            fi
        fi
    else
        info ".dotlocal symlink already correct: â†’ $discovered_path"
    fi
else
    if [[ "$dry_run" == "true" ]]; then
        info "[dry-run] No dotlocal directory found - would use public configs only"
    else
        info "No dotlocal directory found - using public configs only"
    fi
fi

# Clean broken symlinks if requested
if [[ "$clean" == "true" ]]; then
    subheader "Cleanup"
    clean_broken_dotfile_symlinks "$dry_run"
fi

# CRITICAL FIX: Use symlink.sh library instead of duplicate code!
# This eliminates 100+ lines of duplicate symlink logic
export SYMLINK_VERBOSE="$verbose"  # Pass verbose setting to library
create_all_symlinks_with_precedence "$DOTFILES_ROOT" "$discovered_path" "$dry_run" "$force"

# Get the counts from the library
public_count=${SYMLINK_PUBLIC_COUNT:-0}
local_count=${SYMLINK_LOCAL_COUNT:-0}
skip_count=${SYMLINK_SKIP_COUNT:-0}

# Handle Claude-specific symlinks (this is relink-specific business logic)
claude_count=0
claude_global_count=0
claude_agent_count=0

if [[ -n "$discovered_path" ]] && [[ -d "$discovered_path" ]]; then
    # Process Claude commands, agents, and global files
    CLAUDE_COMMANDS_DIR="$discovered_path/claude/commands"
    CLAUDE_GLOBAL_DIR="$discovered_path/claude/global"
    CLAUDE_AGENTS_DIR="$discovered_path/claude/agents"
    GLOBAL_CLAUDE_DIR="$HOME/.claude/commands"
    GLOBAL_CLAUDE_AGENTS="$HOME/.claude/agents"
    GLOBAL_CLAUDE_ROOT="$HOME/.claude"

    # Claude commands processing
    if [[ -d "$CLAUDE_COMMANDS_DIR" ]]; then
        if [[ "$dry_run" == "true" ]]; then
            info "Processing Claude commands (dry-run)"
        else
            progress "Processing Claude commands"
        fi

        # Create directory and clean if needed
        if [[ "$dry_run" == "false" ]]; then
            [[ ! -d "$GLOBAL_CLAUDE_DIR" ]] && mkdir -p "$GLOBAL_CLAUDE_DIR"

            if [[ "$clean" == "true" ]]; then
                while IFS= read -r symlink; do
                    if [[ ! -e "$symlink" ]]; then
                        rm -f "$symlink"
                        [[ "$verbose" == "true" ]] && list_item "Removed broken: $(basename "$symlink")"
                    fi
                done < <(find "$GLOBAL_CLAUDE_DIR" -type l 2>/dev/null)
            fi
        fi

        # Link all Claude command files
        while IFS= read -r source; do
            filename=$(basename "$source")
            target="$GLOBAL_CLAUDE_DIR/$filename"

            if [[ "$dry_run" == "true" ]]; then
                if [[ -L "$target" ]]; then
                    current_target=$(readlink "$target")
                    if [[ "$current_target" != "$source" ]]; then
                        info "[dry-run] Would update Claude command: $filename"
                        claude_count=$((claude_count + 1))
                    elif [[ "$verbose" == "true" ]]; then
                        info "[dry-run] Claude command already correct: $filename"
                    fi
                elif [[ ! -e "$target" ]]; then
                    info "[dry-run] Would link Claude command: $filename"
                    claude_count=$((claude_count + 1))
                fi
            else
                # Real symlink creation
                update_needed=false
                if [[ -L "$target" ]]; then
                    current_target=$(readlink "$target")
                    if [[ "$current_target" != "$source" ]] || [[ ! -e "$target" ]] || [[ "$force" == "true" ]]; then
                        update_needed=true
                        rm -f "$target"
                    fi
                elif [[ ! -e "$target" ]]; then
                    update_needed=true
                elif [[ -e "$target" ]] && [[ ! -L "$target" ]]; then
                    warning "Regular file exists, skipping: $filename"
                    continue
                fi

                if [[ "$update_needed" == "true" ]]; then
                    if create_application_symlink "$source" "$target" "$filename" "$force" "$dry_run" "$verbose"; then
                        claude_count=$((claude_count + 1))
                        [[ "$verbose" == "true" ]] && list_item "Claude command linked: $filename"
                    else
                        error "Failed to link Claude command: $filename"
                    fi
                elif [[ "$verbose" == "true" ]]; then
                    indent "Claude command already correct: $filename"
                fi
            fi
        done < <(find "$CLAUDE_COMMANDS_DIR" -name "*.md" 2>/dev/null)
    fi

    # Claude global files (PROTOCOL.md, CLAUDE.md)
    if [[ -d "$CLAUDE_GLOBAL_DIR" ]]; then
        if [[ "$dry_run" == "true" ]]; then
            info "Processing Claude global files (dry-run)"
        else
            progress "Processing Claude global files"
            [[ ! -d "$GLOBAL_CLAUDE_ROOT" ]] && mkdir -p "$GLOBAL_CLAUDE_ROOT"
        fi

        for file in "PROTOCOL.md" "CLAUDE.md"; do
            source_file="$CLAUDE_GLOBAL_DIR/$file"
            target="$GLOBAL_CLAUDE_ROOT/$file"

            if [[ -f "$source_file" ]]; then
                if [[ "$dry_run" == "true" ]]; then
                    if [[ -L "$target" ]]; then
                        current_target=$(readlink "$target")
                        if [[ "$current_target" != "$source_file" ]]; then
                            info "[dry-run] Would update Claude global file: $file"
                            claude_global_count=$((claude_global_count + 1))
                        elif [[ "$verbose" == "true" ]]; then
                            info "[dry-run] Claude global file already correct: $file"
                        fi
                    elif [[ ! -e "$target" ]]; then
                        info "[dry-run] Would link Claude global file: $file"
                        claude_global_count=$((claude_global_count + 1))
                    fi
                else
                    # Real symlink creation
                    update_needed=false
                    if [[ -L "$target" ]]; then
                        current_target=$(readlink "$target")
                        if [[ "$current_target" != "$source_file" ]] || [[ ! -e "$target" ]] || [[ "$force" == "true" ]]; then
                            update_needed=true
                            rm -f "$target"
                        fi
                    elif [[ ! -e "$target" ]]; then
                        update_needed=true
                    elif [[ -e "$target" ]] && [[ ! -L "$target" ]]; then
                        warning "Regular file exists, skipping: $file"
                        continue
                    fi

                    if [[ "$update_needed" == "true" ]]; then
                        if create_application_symlink "$source_file" "$target" "$file" "$force" "$dry_run" "$verbose"; then
                            claude_global_count=$((claude_global_count + 1))
                            [[ "$verbose" == "true" ]] && list_item "Claude global file linked: $file"
                        else
                            error "Failed to link Claude global file: $file"
                        fi
                    elif [[ "$verbose" == "true" ]]; then
                        indent "Claude global file already correct: $file"
                    fi
                fi
            fi
        done
    fi

    # Claude agents processing
    if [[ -d "$CLAUDE_AGENTS_DIR" ]]; then
        if [[ "$dry_run" == "true" ]]; then
            info "Processing Claude agents (dry-run)"
        else
            progress "Processing Claude agents"
            [[ ! -d "$GLOBAL_CLAUDE_AGENTS" ]] && mkdir -p "$GLOBAL_CLAUDE_AGENTS"

            if [[ "$clean" == "true" ]] || [[ "$force" == "true" ]]; then
                while IFS= read -r symlink; do
                    if [[ ! -e "$symlink" ]]; then
                        rm -f "$symlink"
                        [[ "$verbose" == "true" ]] && list_item "Removed broken: $(basename "$symlink")"
                    fi
                done < <(find "$GLOBAL_CLAUDE_AGENTS" -type l 2>/dev/null)
            fi
        fi

        # Link all Claude agent files (excluding README.md)
        while IFS= read -r source; do
            filename=$(basename "$source")

            # Skip README files
            if [[ "$filename" == "README.md" ]] || [[ "$filename" == "readme.md" ]]; then
                continue
            fi

            target="$GLOBAL_CLAUDE_AGENTS/$filename"

            if [[ "$dry_run" == "true" ]]; then
                if [[ -L "$target" ]]; then
                    current_target=$(readlink "$target")
                    if [[ "$current_target" != "$source" ]]; then
                        info "[dry-run] Would update Claude agent: $filename"
                        claude_agent_count=$((claude_agent_count + 1))
                    elif [[ "$verbose" == "true" ]]; then
                        info "[dry-run] Claude agent already correct: $filename"
                    fi
                elif [[ ! -e "$target" ]]; then
                    info "[dry-run] Would link Claude agent: $filename"
                    claude_agent_count=$((claude_agent_count + 1))
                fi
            else
                # Real symlink creation
                update_needed=false
                if [[ -L "$target" ]]; then
                    current_target=$(readlink "$target")
                    if [[ "$current_target" != "$source" ]] || [[ ! -e "$target" ]] || [[ "$force" == "true" ]]; then
                        update_needed=true
                        rm -f "$target"
                    fi
                elif [[ ! -e "$target" ]]; then
                    update_needed=true
                elif [[ -e "$target" ]] && [[ ! -L "$target" ]]; then
                    warning "Regular file exists, skipping: $filename"
                    continue
                fi

                if [[ "$update_needed" == "true" ]]; then
                    if create_application_symlink "$source" "$target" "$filename" "$force" "$dry_run" "$verbose"; then
                        claude_agent_count=$((claude_agent_count + 1))
                        [[ "$verbose" == "true" ]] && list_item "Claude agent linked: $filename"
                    else
                        error "Failed to link Claude agent: $filename"
                    fi
                elif [[ "$verbose" == "true" ]]; then
                    indent "Claude agent already correct: $filename"
                fi
            fi
        done < <(find "$CLAUDE_AGENTS_DIR" -name "*.md" 2>/dev/null)
    fi

    # Handle Claude Desktop MCP configuration symlink
    CLAUDE_DESKTOP_DIR="$HOME/Library/Application Support/Claude"
    if [[ -d "$CLAUDE_DESKTOP_DIR" ]]; then
        MCP_SERVERS_SOURCE="$discovered_path/claude/mcp/servers.json"
        CLAUDE_DESKTOP_CONFIG="$CLAUDE_DESKTOP_DIR/claude_desktop_config.json"

        if [[ -f "$MCP_SERVERS_SOURCE" ]]; then
            if [[ "$dry_run" == "true" ]]; then
                if [[ -L "$CLAUDE_DESKTOP_CONFIG" ]]; then
                    current_target=$(readlink "$CLAUDE_DESKTOP_CONFIG")
                    if [[ "$current_target" != "$MCP_SERVERS_SOURCE" ]]; then
                        info "[dry-run] Would update Claude Desktop MCP config symlink"
                    elif [[ "$verbose" == "true" ]]; then
                        info "[dry-run] Claude Desktop MCP config already correct"
                    fi
                elif [[ ! -e "$CLAUDE_DESKTOP_CONFIG" ]]; then
                    info "[dry-run] Would create Claude Desktop MCP config symlink"
                fi
            else
                create_application_symlink "$MCP_SERVERS_SOURCE" "$CLAUDE_DESKTOP_CONFIG" "Claude Desktop MCP config" "$force" "$dry_run" "$verbose"
            fi
        fi
    fi

    # Sync MCP servers to Claude Code global configuration
    MCP_SETUP_SCRIPT="$discovered_path/claude/mcp/mcp-setup-global"
    if [[ -f "$MCP_SETUP_SCRIPT" ]] && [[ -x "$MCP_SETUP_SCRIPT" ]]; then
        if [[ "$dry_run" == "true" ]]; then
            info "[dry-run] Would sync MCP servers to Claude Code global configuration"
        else
            subheader "MCP Server Sync"
            progress "Syncing MCP servers to Claude Code"

            if [[ "$verbose" == "true" ]]; then
                if "$MCP_SETUP_SCRIPT"; then
                    success "MCP servers synced successfully"
                else
                    warning "MCP server sync completed with some errors"
                fi
            else
                if MCP_OUTPUT=$("$MCP_SETUP_SCRIPT" 2>&1); then
                    success "MCP servers synced successfully"
                else
                    warning "MCP server sync completed with some errors"
                    if [[ -n "$MCP_OUTPUT" ]]; then
                        echo "$MCP_OUTPUT" | while IFS= read -r line; do
                            indent "$line"
                        done
                    fi
                fi
            fi
        fi
    elif [[ -f "$discovered_path/claude/mcp/servers.json" ]]; then
        if [[ "$dry_run" == "false" ]]; then
            info "MCP servers.json found but mcp-setup-global script not available"
            indent "Run manually: $discovered_path/claude/mcp/mcp-setup-global"
        fi
    fi
fi

# Summary (counts from symlink.sh library + Claude-specific counts)
if [[ "$dry_run" == "false" ]]; then
    blank
    total_count=$((public_count + local_count + claude_count + claude_global_count + claude_agent_count))
    summary "Relink" $total_count 0 0

    if [[ $skip_count -gt 0 ]]; then
        info "Skipped $skip_count public configs (have local overrides)"
    fi
    if [[ $claude_count -gt 0 ]]; then
        info "Claude commands updated: $claude_count"
    fi
    if [[ $claude_global_count -gt 0 ]]; then
        info "Claude global files updated: $claude_global_count"
    fi
    if [[ $claude_agent_count -gt 0 ]]; then
        info "Claude agents updated: $claude_agent_count"
    fi
else
    blank
    separator
    info "Dry-run complete. No changes were made."
    blank
    info "Would create:"
    list_item "Public configs: $public_count"
    list_item "Local overrides: $local_count"
    [[ $claude_count -gt 0 ]] && list_item "Claude commands: $claude_count"
    [[ $claude_global_count -gt 0 ]] && list_item "Claude global files: $claude_global_count"
    [[ $claude_agent_count -gt 0 ]] && list_item "Claude agents: $claude_agent_count"
    [[ $skip_count -gt 0 ]] && list_item "Skip (have local): $skip_count"
fi