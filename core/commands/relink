#!/usr/bin/env bash
#
# dots relink - Recreate all symlinks with local precedence
# Refactored to use unified UI style
#

set -e

# Get the dotfiles root directory
DOTFILES_ROOT="$(cd "$(dirname "$0")/../.." && pwd -P)"
CORE_DIR="$DOTFILES_ROOT/core"

# Source libraries
source "$CORE_DIR/lib/ui.sh"
source "$CORE_DIR/lib/validate-config.sh"

# Load DOTLOCAL from dotfiles.conf if it exists
DOTLOCAL=""
if [[ -f "$DOTFILES_ROOT/dotfiles.conf" ]]; then
    # Source only variable assignments, not commands
    eval "$(grep '^[A-Z_]*=' "$DOTFILES_ROOT/dotfiles.conf" 2>/dev/null || true)"
fi

# Parse options
dry_run=false
force=false
clean=false
verbose=false

while test $# -gt 0; do
  case "$1" in
    --dry-run)
      dry_run=true
      ;;
    --force)
      force=true
      ;;
    --clean)
      clean=true
      ;;
    --verbose)
      verbose=true
      ;;
    --help)
      header "ðŸ“Ž Dots Relink"
      blank
      info "Recreate all dotfile symlinks with local precedence"
      blank
      subheader "Usage"
      info "  dots relink [options]"
      blank
      subheader "Options"
      list_item "--dry-run    Show what would be done without making changes"
      list_item "--force      Force overwrite existing files/symlinks"
      list_item "--clean      Clean broken symlinks before relinking"
      list_item "--verbose    Show detailed output"
      list_item "--help       Show this help message"
      blank
      subheader "Precedence Order"
      info "  1. Local configs (from \$DOTLOCAL if set)"
      info "  2. Public configs (from \$DOTFILES_ROOT)"
      blank
      exit 0
      ;;
    *)
      error "Unknown option: $1"
      info "Run 'dots relink --help' for usage"
      exit 1
      ;;
  esac
  shift
done

# Main execution
header "ðŸ“Ž Dotfiles Relink"

# Validate configuration
subheader "Configuration Validation"
progress "Validating configuration"

if [[ -f "$DOTFILES_ROOT/dotfiles.conf" ]]; then
    # Check for dangerous patterns before sourcing
    if grep -q "^[^#]*ln -s" "$DOTFILES_ROOT/dotfiles.conf" 2>/dev/null; then
        error "Uncommented 'ln -s' command found in dotfiles.conf"
        error "This would execute when the config is sourced"
        grep -n "^[^#]*ln -s" "$DOTFILES_ROOT/dotfiles.conf" | while read -r line; do
            indent "Line $line" 2
        done
        error "Comment out or remove these lines before proceeding"
        exit 1
    fi
fi

if ! validate_configuration; then
    error "Configuration errors detected"
    info "Run 'dots status' for details about the configuration issues"
    info "Fix the issues in dotfiles.conf and try again"
    exit 1
fi

success "Configuration valid"

# Show current configuration
subheader "Environment"
key_value "DOTFILES_ROOT" "$DOTFILES_ROOT"
if [[ -n "$DOTLOCAL" ]]; then
    key_value "DOTLOCAL" "$DOTLOCAL"
else
    key_value "DOTLOCAL" "Not configured"
fi

# Create or update .dotlocal symlink if DOTLOCAL is set
if [[ -n "$DOTLOCAL" ]]; then
    # Expand tilde in DOTLOCAL path
    DOTLOCAL_EXPANDED=$(expand_path "$DOTLOCAL")
    LOCAL_SYMLINK_PATH="$DOTFILES_ROOT/.dotlocal"
    
    if [[ "$dry_run" == "true" ]]; then
        info "[dry-run] Would create/update .dotlocal symlink â†’ $DOTLOCAL"
    else
        # Check if the local dots directory exists
        if [[ -d "$DOTLOCAL_EXPANDED" ]]; then
            # Create .dotlocal symlink if it doesn't exist
            if [ ! -e "$LOCAL_SYMLINK_PATH" ]; then
                ln -sfn "$DOTLOCAL_EXPANDED" "$LOCAL_SYMLINK_PATH"
                success "Created .dotlocal symlink â†’ $DOTLOCAL"
            elif [ -L "$LOCAL_SYMLINK_PATH" ]; then
                # Update existing symlink if it points to wrong location
                current_target=$(readlink "$LOCAL_SYMLINK_PATH")
                if [ "$current_target" != "$DOTLOCAL_EXPANDED" ]; then
                    ln -sfn "$DOTLOCAL_EXPANDED" "$LOCAL_SYMLINK_PATH"
                    success "Updated .dotlocal symlink â†’ $DOTLOCAL"
                else
                    [[ "$verbose" == "true" ]] && info ".dotlocal symlink already correct"
                fi
            else
                warning "$LOCAL_SYMLINK_PATH exists but is not a symlink"
            fi
            
            
            # Create/update core symlink in DOTLOCAL pointing back to dotfiles/core
            CORE_SYMLINK_PATH="$DOTLOCAL_EXPANDED/core"
            if [ ! -e "$CORE_SYMLINK_PATH" ]; then
                ln -sfn "$DOTFILES_ROOT/core" "$CORE_SYMLINK_PATH"
                success "Created core symlink in local: core â†’ $DOTFILES_ROOT/core"
            elif [ -L "$CORE_SYMLINK_PATH" ]; then
                # Update existing symlink if it points to wrong location
                current_core_target=$(readlink "$CORE_SYMLINK_PATH")
                if [ "$current_core_target" != "$DOTFILES_ROOT/core" ]; then
                    ln -sfn "$DOTFILES_ROOT/core" "$CORE_SYMLINK_PATH"
                    success "Updated core symlink in local: core â†’ $DOTFILES_ROOT/core"
                else
                    [[ "$verbose" == "true" ]] && info "Core symlink in local already correct"
                fi
            else
                warning "$CORE_SYMLINK_PATH exists but is not a symlink"
            fi
        else
            warning "DOTLOCAL is set but directory does not exist: $DOTLOCAL"
        fi
    fi
fi

# Clean broken symlinks if requested
if [[ "$clean" == "true" ]]; then
    subheader "Cleanup"
    progress "Cleaning broken symlinks"
    
    # Source symlink functions
    source "$CORE_DIR/lib/symlink.sh"
    
    broken_count=0
    while IFS= read -r symlink; do
        if [[ ! -e "$symlink" ]]; then
            if [[ "$dry_run" == "true" ]]; then
                info "[dry-run] Would remove broken symlink: $symlink"
            else
                rm "$symlink"
                [[ "$verbose" == "true" ]] && list_item "Removed: $(basename "$symlink")"
            fi
            broken_count=$((broken_count + 1))
        fi
    done < <(find "$HOME" -maxdepth 1 -type l -name ".*" 2>/dev/null)
    
    if [[ $broken_count -gt 0 ]]; then
        success "Cleaned $broken_count broken symlinks"
    else
        info "No broken symlinks found"
    fi
fi

# Create all symlinks with precedence
subheader "Symlink Creation"

# Track counters
public_count=0
local_count=0
skip_count=0

# Helper function for creating symlinks with UI
create_symlink_ui() {
    local source="$1"
    local target="$2"
    local is_local="$3"
    
    if [[ "$dry_run" == "true" ]]; then
        info "[dry-run] Would link $(basename "$target") â†’ $source"
        return 0
    fi
    
    # Create symlink
    if [[ "$force" == "true" ]] || [[ ! -e "$target" && ! -L "$target" ]]; then
        # Remove existing to ensure clean replacement
        if [[ -e "$target" || -L "$target" ]]; then
            rm -rf "$target"
        fi
        
        # Create parent directory if needed
        local parent_dir=$(dirname "$target")
        [[ ! -d "$parent_dir" ]] && mkdir -p "$parent_dir"
        
        if ln -s "$source" "$target"; then
            if [[ "$verbose" == "true" ]]; then
                if [[ "$is_local" == "true" ]]; then
                    list_item "$(basename "$target") â†’ [LOCAL] $(basename "$(dirname "$source")")/$(basename "$source")"
                else
                    list_item "$(basename "$target") â†’ $(basename "$(dirname "$source")")/$(basename "$source")"
                fi
            fi
            return 0
        else
            error "Failed to link: $target"
            return 1
        fi
    else
        return 2  # Already exists
    fi
}

# Source symlink helper functions
source "$CORE_DIR/lib/symlink.sh"

# Process public configs first
if [[ "$dry_run" == "true" ]]; then
    info "Processing public configurations (dry-run)"
else
    progress "Processing public configurations"
fi

if [[ -d "$DOTFILES_ROOT" ]]; then
    while IFS= read -r source; do
        should_exclude "$source" && continue
        
        target=$(get_symlink_target "$source")
        
        # Skip if local version exists (will be handled in phase 2)
        if [[ -n "$DOTLOCAL" ]]; then
            # Expand tilde in DOTLOCAL path
            DOTLOCAL_EXPANDED=$(expand_path "$DOTLOCAL")
            if [[ -d "$DOTLOCAL_EXPANDED" ]]; then
                relative_path="${source#$DOTFILES_ROOT/}"
                local_equivalent="$DOTLOCAL_EXPANDED/${relative_path}"
                if [[ -f "$local_equivalent" ]]; then
                    skip_count=$((skip_count + 1))
                    [[ "$verbose" == "true" ]] && indent "Skipped $(basename "$target") (has local override)"
                    continue
                fi
            fi
        fi
        
        if create_symlink_ui "$source" "$target" false; then
            public_count=$((public_count + 1))
        fi
    done < <(find "$DOTFILES_ROOT" -name "*.symlink" -not -path "*/.dotlocal/*" 2>/dev/null)
fi

[[ "$dry_run" == "false" ]] && success "Public configurations linked: $public_count"

# Process local configs second (they override)
if [[ -n "$DOTLOCAL" ]]; then
    # Expand tilde in DOTLOCAL path
    DOTLOCAL_EXPANDED=$(expand_path "$DOTLOCAL")
    if [[ -d "$DOTLOCAL_EXPANDED" ]]; then
    if [[ "$dry_run" == "true" ]]; then
        info "Processing local overrides (dry-run)"
    else
        progress "Processing local overrides"
    fi
    
    while IFS= read -r source; do
        should_exclude "$source" && continue
        
        target=$(get_symlink_target "$source")
        # Force mode for local - they always override
        if create_symlink_ui "$source" "$target" true; then
            local_count=$((local_count + 1))
        fi
    done < <(find "$DOTLOCAL_EXPANDED" -name "*.symlink" 2>/dev/null)
    
    [[ "$dry_run" == "false" ]] && success "Local overrides linked: $local_count"
    else
        [[ "$dry_run" == "false" ]] && info "Local directory does not exist"
    fi
else
    [[ "$dry_run" == "false" ]] && info "No local folder configured"
fi

# Process Claude commands, agents, and global files if local directory exists
claude_count=0
claude_global_count=0
claude_agent_count=0
if [[ -n "$DOTLOCAL" ]]; then
    DOTLOCAL_EXPANDED=$(expand_path "$DOTLOCAL")
    CLAUDE_COMMANDS_DIR="$DOTLOCAL_EXPANDED/claude/commands"
    CLAUDE_GLOBAL_DIR="$DOTLOCAL_EXPANDED/claude/global"
    CLAUDE_AGENTS_DIR="$DOTLOCAL_EXPANDED/claude/agents"
    GLOBAL_CLAUDE_DIR="$HOME/.claude/commands"
    GLOBAL_CLAUDE_AGENTS="$HOME/.claude/agents"
    GLOBAL_CLAUDE_ROOT="$HOME/.claude"
    
    if [[ -d "$CLAUDE_COMMANDS_DIR" ]]; then
        if [[ "$dry_run" == "true" ]]; then
            info "Processing Claude commands (dry-run)"
        else
            progress "Processing Claude commands"
        fi
        
        # Ensure global Claude commands directory exists
        if [[ "$dry_run" == "false" ]]; then
            [[ ! -d "$GLOBAL_CLAUDE_DIR" ]] && mkdir -p "$GLOBAL_CLAUDE_DIR"
        fi
        
        # Clean broken Claude command symlinks
        if [[ "$clean" == "true" ]] && [[ "$dry_run" == "false" ]]; then
            while IFS= read -r symlink; do
                if [[ ! -e "$symlink" ]]; then
                    rm -f "$symlink"
                    [[ "$verbose" == "true" ]] && list_item "Removed broken: $(basename "$symlink")"
                fi
            done < <(find "$GLOBAL_CLAUDE_DIR" -type l 2>/dev/null)
        fi
        
        # Link all Claude command files
        while IFS= read -r source; do
            filename=$(basename "$source")
            target="$GLOBAL_CLAUDE_DIR/$filename"
            
            if [[ "$dry_run" == "true" ]]; then
                # Check if would need updating
                if [[ -L "$target" ]]; then
                    current_target=$(readlink "$target")
                    if [[ "$current_target" != "$source" ]]; then
                        info "[dry-run] Would update Claude command: $filename"
                        claude_count=$((claude_count + 1))
                    elif [[ "$verbose" == "true" ]]; then
                        info "[dry-run] Claude command already correct: $filename"
                    fi
                elif [[ ! -e "$target" ]]; then
                    info "[dry-run] Would link Claude command: $filename"
                    claude_count=$((claude_count + 1))
                fi
            else
                # Check if symlink exists and points to wrong location
                if [[ -L "$target" ]]; then
                    current_target=$(readlink "$target")
                    if [[ "$current_target" != "$source" ]] || [[ ! -e "$target" ]] || [[ "$force" == "true" ]]; then
                        rm -f "$target"
                        if ln -s "$source" "$target"; then
                            claude_count=$((claude_count + 1))
                            [[ "$verbose" == "true" ]] && list_item "Claude command updated: $filename"
                        else
                            error "Failed to link Claude command: $filename"
                        fi
                    elif [[ "$verbose" == "true" ]]; then
                        indent "Claude command already correct: $filename"
                    fi
                elif [[ ! -e "$target" ]]; then
                    # Create new symlink
                    if ln -s "$source" "$target"; then
                        claude_count=$((claude_count + 1))
                        [[ "$verbose" == "true" ]] && list_item "Claude command linked: $filename"
                    else
                        error "Failed to link Claude command: $filename"
                    fi
                elif [[ -e "$target" ]] && [[ ! -L "$target" ]]; then
                    warning "Regular file exists, skipping: $filename"
                fi
            fi
        done < <(find "$CLAUDE_COMMANDS_DIR" -name "*.md" 2>/dev/null)
        
        if [[ "$dry_run" == "false" ]] && [[ $claude_count -gt 0 ]]; then
            success "Claude commands linked: $claude_count"
        fi
    fi
    
    # Process Claude global files (PROTOCOL.md, CLAUDE.md)
    if [[ -d "$CLAUDE_GLOBAL_DIR" ]]; then
        if [[ "$dry_run" == "true" ]]; then
            info "Processing Claude global files (dry-run)"
        else
            progress "Processing Claude global files"
        fi
        
        # Ensure global Claude root directory exists
        if [[ "$dry_run" == "false" ]]; then
            [[ ! -d "$GLOBAL_CLAUDE_ROOT" ]] && mkdir -p "$GLOBAL_CLAUDE_ROOT"
        fi
        
        # Link PROTOCOL.md and CLAUDE.md
        for file in "PROTOCOL.md" "CLAUDE.md"; do
            source="$CLAUDE_GLOBAL_DIR/$file"
            target="$GLOBAL_CLAUDE_ROOT/$file"
            
            if [[ -f "$source" ]]; then
                if [[ "$dry_run" == "true" ]]; then
                    # Check if would need updating
                    if [[ -L "$target" ]]; then
                        current_target=$(readlink "$target")
                        if [[ "$current_target" != "$source" ]]; then
                            info "[dry-run] Would update Claude global file: $file"
                            claude_global_count=$((claude_global_count + 1))
                        elif [[ "$verbose" == "true" ]]; then
                            info "[dry-run] Claude global file already correct: $file"
                        fi
                    elif [[ ! -e "$target" ]]; then
                        info "[dry-run] Would link Claude global file: $file"
                        claude_global_count=$((claude_global_count + 1))
                    fi
                else
                    # Check if symlink exists and points to wrong location
                    if [[ -L "$target" ]]; then
                        current_target=$(readlink "$target")
                        if [[ "$current_target" != "$source" ]] || [[ ! -e "$target" ]] || [[ "$force" == "true" ]]; then
                            rm -f "$target"
                            if ln -s "$source" "$target"; then
                                claude_global_count=$((claude_global_count + 1))
                                [[ "$verbose" == "true" ]] && list_item "Claude global file updated: $file"
                            else
                                error "Failed to link Claude global file: $file"
                            fi
                        elif [[ "$verbose" == "true" ]]; then
                            indent "Claude global file already correct: $file"
                        fi
                    elif [[ ! -e "$target" ]]; then
                        # Create new symlink
                        if ln -s "$source" "$target"; then
                            claude_global_count=$((claude_global_count + 1))
                            [[ "$verbose" == "true" ]] && list_item "Claude global file linked: $file"
                        else
                            error "Failed to link Claude global file: $file"
                        fi
                    elif [[ -e "$target" ]] && [[ ! -L "$target" ]]; then
                        warning "Regular file exists, skipping: $file"
                    fi
                fi
            fi
        done
        
        if [[ "$dry_run" == "false" ]] && [[ $claude_global_count -gt 0 ]]; then
            success "Claude global files linked: $claude_global_count"
        fi
    fi
    
    # Process Claude agents
    if [[ -d "$CLAUDE_AGENTS_DIR" ]]; then
        if [[ "$dry_run" == "true" ]]; then
            info "Processing Claude agents (dry-run)"
        else
            progress "Processing Claude agents"
            
            # Ensure global Claude agents directory exists
            [[ ! -d "$GLOBAL_CLAUDE_AGENTS" ]] && mkdir -p "$GLOBAL_CLAUDE_AGENTS"
            
            # Clean broken Claude agent symlinks
            if [[ "$clean" == "true" ]] || [[ "$force" == "true" ]]; then
                while IFS= read -r symlink; do
                    if [[ ! -e "$symlink" ]]; then
                        rm -f "$symlink"
                        [[ "$verbose" == "true" ]] && list_item "Removed broken: $(basename "$symlink")"
                    fi
                done < <(find "$GLOBAL_CLAUDE_AGENTS" -type l 2>/dev/null)
            fi
        fi
        
        # Link all Claude agent files (excluding README.md)
        while IFS= read -r source; do
            filename=$(basename "$source")
            
            # Skip README files
            if [[ "$filename" == "README.md" ]] || [[ "$filename" == "readme.md" ]]; then
                continue
            fi
            
            target="$GLOBAL_CLAUDE_AGENTS/$filename"
            
            if [[ "$dry_run" == "true" ]]; then
                # Check if would need updating
                if [[ -L "$target" ]]; then
                    current_target=$(readlink "$target")
                    if [[ "$current_target" != "$source" ]]; then
                        info "[dry-run] Would update Claude agent: $filename"
                        claude_agent_count=$((claude_agent_count + 1))
                    elif [[ "$verbose" == "true" ]]; then
                        info "[dry-run] Claude agent already correct: $filename"
                    fi
                elif [[ ! -e "$target" ]]; then
                    info "[dry-run] Would link Claude agent: $filename"
                    claude_agent_count=$((claude_agent_count + 1))
                fi
            else
                # Check if symlink exists and points to wrong location
                if [[ -L "$target" ]]; then
                    current_target=$(readlink "$target")
                    if [[ "$current_target" != "$source" ]] || [[ ! -e "$target" ]] || [[ "$force" == "true" ]]; then
                        rm -f "$target"
                        if ln -s "$source" "$target"; then
                            claude_agent_count=$((claude_agent_count + 1))
                            [[ "$verbose" == "true" ]] && list_item "Claude agent updated: $filename"
                        else
                            error "Failed to link Claude agent: $filename"
                        fi
                    elif [[ "$verbose" == "true" ]]; then
                        indent "Claude agent already correct: $filename"
                    fi
                elif [[ ! -e "$target" ]]; then
                    # Create new symlink
                    if ln -s "$source" "$target"; then
                        claude_agent_count=$((claude_agent_count + 1))
                        [[ "$verbose" == "true" ]] && list_item "Claude agent linked: $filename"
                    else
                        error "Failed to link Claude agent: $filename"
                    fi
                elif [[ -e "$target" ]] && [[ ! -L "$target" ]]; then
                    warning "Regular file exists, skipping: $filename"
                fi
            fi
        done < <(find "$CLAUDE_AGENTS_DIR" -name "*.md" 2>/dev/null)
        
        if [[ "$dry_run" == "false" ]] && [[ $claude_agent_count -gt 0 ]]; then
            success "Claude agents linked: $claude_agent_count"
        fi
    fi
    
    # Handle Claude Desktop MCP configuration symlink
    CLAUDE_DESKTOP_DIR="$HOME/Library/Application Support/Claude"
    if [[ -d "$CLAUDE_DESKTOP_DIR" ]]; then
        MCP_SERVERS_SOURCE="$DOTLOCAL_EXPANDED/claude/mcp/servers.json"
        CLAUDE_DESKTOP_CONFIG="$CLAUDE_DESKTOP_DIR/claude_desktop_config.json"
        
        if [[ -f "$MCP_SERVERS_SOURCE" ]]; then
            if [[ "$dry_run" == "true" ]]; then
                # Check if would need updating
                if [[ -L "$CLAUDE_DESKTOP_CONFIG" ]]; then
                    current_target=$(readlink "$CLAUDE_DESKTOP_CONFIG")
                    if [[ "$current_target" != "$MCP_SERVERS_SOURCE" ]]; then
                        info "[dry-run] Would update Claude Desktop MCP config symlink"
                    elif [[ "$verbose" == "true" ]]; then
                        info "[dry-run] Claude Desktop MCP config already correct"
                    fi
                elif [[ ! -e "$CLAUDE_DESKTOP_CONFIG" ]]; then
                    info "[dry-run] Would create Claude Desktop MCP config symlink"
                fi
            else
                # Check if symlink exists and points to wrong location
                if [[ -L "$CLAUDE_DESKTOP_CONFIG" ]]; then
                    current_target=$(readlink "$CLAUDE_DESKTOP_CONFIG")
                    if [[ "$current_target" != "$MCP_SERVERS_SOURCE" ]] || [[ "$force" == "true" ]]; then
                        ln -sf "$MCP_SERVERS_SOURCE" "$CLAUDE_DESKTOP_CONFIG"
                        [[ "$verbose" == "true" ]] && success "Claude Desktop MCP config updated"
                    elif [[ "$verbose" == "true" ]]; then
                        indent "Claude Desktop MCP config already correct"
                    fi
                elif [[ ! -e "$CLAUDE_DESKTOP_CONFIG" ]]; then
                    # Create new symlink
                    ln -sf "$MCP_SERVERS_SOURCE" "$CLAUDE_DESKTOP_CONFIG"
                    [[ "$verbose" == "true" ]] && success "Claude Desktop MCP config linked"
                elif [[ -e "$CLAUDE_DESKTOP_CONFIG" ]] && [[ ! -L "$CLAUDE_DESKTOP_CONFIG" ]]; then
                    warning "Claude Desktop config exists as regular file, skipping MCP link"
                fi
            fi
        fi
    fi
fi

# Summary
if [[ "$dry_run" == "false" ]]; then
    blank
    summary "Relink" $((public_count + local_count + claude_count + claude_global_count + claude_agent_count)) 0 0
    
    if [[ $skip_count -gt 0 ]]; then
        info "Skipped $skip_count public configs (have local overrides)"
    fi
    if [[ $claude_count -gt 0 ]]; then
        info "Claude commands updated: $claude_count"
    fi
    if [[ $claude_global_count -gt 0 ]]; then
        info "Claude global files updated: $claude_global_count"
    fi
    if [[ $claude_agent_count -gt 0 ]]; then
        info "Claude agents updated: $claude_agent_count"
    fi
else
    blank
    separator
    info "Dry-run complete. No changes were made."
    blank
    info "Would create:"
    list_item "Public configs: $public_count"
    list_item "Local overrides: $local_count"
    [[ $claude_count -gt 0 ]] && list_item "Claude commands: $claude_count"
    [[ $claude_global_count -gt 0 ]] && list_item "Claude global files: $claude_global_count"
    [[ $claude_agent_count -gt 0 ]] && list_item "Claude agents: $claude_agent_count"
    [[ $skip_count -gt 0 ]] && list_item "Skip (have local): $skip_count"
fi